library(easyEWAS)
library(tidyverse)
outpath = "D:/test"
ExpoPath = "D:/R/Rwork/Rhistory/shiny/testdata/sampledata.xlsx"
MethyPath = "D:/R/Rwork/Rhistory/shiny/testdata/methydata.xlsx"
res <- initEWAS(outpath = outpath)
res <- loadEWAS(input = res, ExpoPath =  ExpoPath, MethyPath = MethyPath)
res$Data$Expo
Vars = "sex,batch"
res <- transEWAS(res, Vars = Vars, TypeTo = "factor")
adjustVar = "sex,age"
batch = "batch"
plot = TRUE
par.prior = TRUE
mean.only = FALSE
ref.batch = NULL
parallel = FALSE
core = NULL
colnames(res$Data$Expo)
res <- batchEWAS(input = res, adjustVar = adjustVar,
batch = "batch", parallel = F, core = 1)
res$Data$Expo
input = res
filename ="default"
model = "lm"
expo = 'age'
cov = "sex,LYMPHPER,BMI"
cov = NULL
random = NULL
time = NULL
status = NULL
adjustP = TRUE
chipType = "EPICV2"
core = 6
res <- easyEWAS::startEWAS(res,
filename =filename,
model = model,
expo = expo,
cov = cov,
random = random,
time = time,
status = status,
adjustP = adjustP,
chipType = chipType,
core = core)
## set parallel parameters----
message("Start the EWAS analysis...")
if (core == "default") {
no_cores <- parallel::detectCores(logical = FALSE) - 1
} else {
no_cores <- core
}
future::plan(multisession, workers = no_cores)
library(furrr)
library(future)
## set parallel parameters----
message("Start the EWAS analysis...")
if (core == "default") {
no_cores <- parallel::detectCores(logical = FALSE) - 1
} else {
no_cores <- core
}
future::plan(multisession, workers = no_cores)
# 1. Set up parallel plan
future::plan(multisession, workers = no_cores)
# 2. Define process function
process_one <- function(idx) {
tryCatch({
cg <- df_beta[idx, , drop = FALSE]
result <- ewasfun(cg, formula, covdata)
as.numeric(result)
}, error = function(e) {
rep(NA_real_, result_cols)
})
}
# 3. Run parallel computation
message("Start the EWAS analysis...")
tictoc::tic("EWAS parallel computation")
modelres_list <- furrr::future_map(1:nrow(df_beta), process_one, .options = furrr::furrr_options(seed = TRUE))
message("It will take some time, please be patient...")
expo <- if (is.null(expo) || expo == "default") "var" else expo
# peform EWAS analysis--------------------------------------------------------
## calculate factor number
expo_vec <- unlist(input$Data$Expo[, expo])
facnum <- if (is.factor(expo_vec)) length(levels(expo_vec)) else 2
if (!is.factor(expo_vec) && model %in% c("lm", "lmer") && length(unique(expo_vec)) <= 4) {
warning(paste0("Exposure variable '", expo, "' is not a factor but has only ",
length(unique(expo_vec)), " unique values. ",
"If this is a categorical variable, please use transEWAS() to convert it."))
}
## define ewas function-----
ewasfun <- function(cg, ff, cov) {
cov$cpg <- as.vector(t(cg))
res <- tryCatch({
if (model == "lm") {
out <- summary(lm(ff, data = cov))
unlist(lapply(2:facnum, function(i) out$coefficients[i, c(1, 2, 4)]))
} else if (model == "lmer") {
out <- summary(lmer(ff, data = cov))
unlist(lapply(2:facnum, function(i) out$coefficients[i, c(1, 2, 5)]))
} else if (model == "cox") {
out <- summary(coxph(ff, data = cov))
c(as.vector(out$conf.int[1, c(1, 3, 4)]), out$coefficients[1, 5])
} else {
stop("Unsupported model: ", model)
}
}, error = function(e) {
if (model %in% c("lm", "lmer")) return(rep(NA_real_, 3 * (facnum - 1)))
if (model == "cox") return(rep(NA_real_, 4))
})
return(res)
}
model -> input$model
## set ewas parameter
VarCov <- if (!is.null(cov)) unlist(strsplit(cov, ",")) else character(0)
required_cols <- switch(model,
"lm"   = c(expo, VarCov),
"lmer" = c(expo, VarCov, random),
"cox"  = c(time, status, VarCov)
)
covdata <- input$Data$Expo[, required_cols, drop = FALSE]
if (model == "lmer") {
colnames(covdata)[match(random, colnames(covdata))] <- "random"
input$random <- random
} else if (model == "cox") {
colnames(covdata)[match(time, colnames(covdata))] <- "time"
colnames(covdata)[match(status, colnames(covdata))] <- "status"
input$time <- time
input$status <- status
}
input$covdata <- covdata
formula <- switch (model,
"lm" = as.formula(paste0("cpg ~ ",paste(colnames(covdata), collapse = " + "))),
"lmer" = as.formula(paste0("cpg ~ ",paste(colnames(covdata)[-random_index], collapse = " + "), " + (1 | random)")),
"cox" = {
if(length(VarCov) > 0){
as.formula(paste0("Surv(time, status) ~ cpg + ", paste(VarCov, collapse = "+")))
}else{
as.formula("Surv(time, status) ~ cpg")
}
}
)
formula -> input$formula
sample_names <- input$Data$Expo[[1]]
df_beta <- input$Data$Methy[, sample_names, drop = FALSE]
rownames(df_beta) <- input$Data$Methy[[1]]
## set parallel parameters----
message("Start the EWAS analysis...")
if (core == "default") {
no_cores <- parallel::detectCores(logical = FALSE) - 1
} else {
no_cores <- core
}
future::plan(multisession, workers = no_cores)
# 1. Set up parallel plan
future::plan(multisession, workers = no_cores)
# 2. Define process function
process_one <- function(idx) {
tryCatch({
cg <- df_beta[idx, , drop = FALSE]
result <- ewasfun(cg, formula, covdata)
as.numeric(result)
}, error = function(e) {
rep(NA_real_, result_cols)
})
}
# 3. Run parallel computation
message("Start the EWAS analysis...")
tictoc::tic("EWAS parallel computation")
modelres_list <- furrr::future_map(1:nrow(df_beta), process_one, .options = furrr::furrr_options(seed = TRUE))
tictoc::toc()
# 4. Assemble result matrix
modelres <- do.call(rbind, modelres_list)
rownames(modelres) <- rownames(df_beta)
modelres
Sys.time(
modelres_list <- furrr::future_map(1:nrow(df_beta), process_one, .options = furrr::furrr_options(seed = TRUE))
)
system.time(
modelres_list <- furrr::future_map(1:nrow(df_beta), process_one, .options = furrr::furrr_options(seed = TRUE))
)
detach("package:easyEWAS", unload = TRUE, character.only = TRUE)
remove.packages("easyEWAS")
remotes::install_github("ytwangZero/easyEWAS")
library(easyEWAS)
library(tidyverse)
res <- initEWAS(outpath = outpath)
res <- loadEWAS(input = res, ExpoPath =  ExpoPath, MethyPath = MethyPath)
res$Data$Expo
Vars = "sex,batch"
res <- transEWAS(res, Vars = Vars, TypeTo = "factor")
adjustVar = "sex,age"
batch = "batch"
plot = TRUE
par.prior = TRUE
mean.only = FALSE
ref.batch = NULL
parallel = FALSE
core = NULL
colnames(res$Data$Expo)
res <- batchEWAS(input = res, adjustVar = adjustVar,
batch = "batch", parallel = F, core = 1)
res$Data$Expo
input = res
filename ="default"
model = "lm"
expo = 'age'
cov = "sex,LYMPHPER,BMI"
cov = NULL
random = NULL
time = NULL
status = NULL
adjustP = TRUE
chipType = "EPICV2"
core = 6
res <- easyEWAS::startEWAS(res,
filename =filename,
model = model,
expo = expo,
cov = cov,
random = random,
time = time,
status = status,
adjustP = adjustP,
chipType = chipType,
core = core)
startEWAS
install.packages("telegram.bot")
library(telegram.bot)
library(easyEWAS)  # 你的包名
bot <- Bot("7664912505:AAEqoOs-gQzbOgGYej3pGf-YG6oQ57GI8S8")
updater <- Updater(token = bot$get_token())
updater <- Updater(token = "7664912505:AAEqoOs-gQzbOgGYej3pGf-YG6oQ57GI8S8")
bot <- updater$bot
bot
updater <- updater + CommandHandler("start", function(bot, update) {
bot$sendMessage(chat_id = update$message$chat_id, text = "你好，这是你的分析机器人！")
})
# 启动
updater$start_polling()
library(easyEWAS)
outpath = "D:/test"
ExpoPath = "D:/R/Rwork/Rhistory/shiny/testdata/sampledata.xlsx"
MethyPath = "D:/R/Rwork/Rhistory/shiny/testdata/methydata.xlsx"
res <- initEWAS(outpath = outpath)
res <- loadEWAS(input = res, ExpoPath =  ExpoPath, MethyPath = MethyPath)
Vars = "sex"
res <- transEWAS(res, Vars = Vars, TypeTo = "factor")
adjustVar = "sex,age"
batch = "batch"
plot = TRUE
par.prior = TRUE
mean.only = FALSE
ref.batch = NULL
parallel = FALSE
core = NULL
res <- batchEWAS(input = res, adjustVar = adjustVar,
batch = "batch", parallel = F, core = 1)
# res$Data$Expo
input = res
filename ="default"
model = "lm"
expo = 'age'
cov = "sex,BMI"
random = NULL
time = NULL
status = NULL
adjustP = TRUE
chipType = "EPICV2"
core = 10
res <- easyEWAS::startEWAS(input = res,
filename =filename,
model = model,
expo = expo,
cov = cov,
random = random,
time = time,
status = status,
adjustP = adjustP,
chipType = chipType,
core = core)
res <- plotEWAS(input = res,
p = "FDR",
threshold = 0.05)
## boot EWAS----------------
input = res
filterP = "PVAL"
cutoff = 0.05
CpGs = NULL
times = 100
bootCI = "perc"
filename = "default"
res$bootres
res <- easyEWAS::bootEWAS(input = res,
filterP = filterP,
cutoff = cutoff,
CpGs = CpGs,
times = times,
bootCI = bootCI,
filename = filename)
## boot EWAS----------------
input = res
filterP = "FDR"
cutoff = 0.05
CpGs = NULL
times = 100
bootCI = "perc"
filename = "default"
res$bootres
res <- easyEWAS::bootEWAS(input = res,
filterP = filterP,
cutoff = cutoff,
CpGs = CpGs,
times = times,
bootCI = bootCI,
filename = filename)
## boot EWAS----------------
input = res
filterP = "FDR"
cutoff = 0.01
CpGs = NULL
times = 100
bootCI = "perc"
filename = "default"
res$bootres
res <- easyEWAS::bootEWAS(input = res,
filterP = filterP,
cutoff = cutoff,
CpGs = CpGs,
times = times,
bootCI = bootCI,
filename = filename)
## DMR EWAS---------------
input = res
chipType = "EPICV2"
what = "Beta"
epicv2Filter = "mean"
expo = "sex"
# cov = "sex,BMI"
genome = "hg38"
fdrCPG = 0.05
pcutoff = "fdr"
lambda=1000
C = 2
min.cpgs = 2
filename = "default"
res <- dmrEWAS(input = res,
chipType = "EPICV2",
what = "Beta",
epicv2Filter = "mean",
expo = "age",
cov = "sex",
genome = "hg38",
fdrCPG = 0.05,
pcutoff = "fdr",
lambda=1000,
C = 2,
min.cpgs = 2,
filename = "default")
## enrich EWAS------------------
input = res
filename = "default"
method = "GO"
filterP = "PVAL"
cutoff = 0.05
ont = "BP"
pool = FALSE
plot = TRUE
plotType = "dot"
plotcolor = "p.adjust"
showCategory=10
pvalueCutoff = 0.05
pAdjustMethod = "BH"
qvalueCutoff = 0.2
x = "GeneRatio"
width = 11
height = 11
res <- easyEWAS::enrichEWAS(res,
filename = "default",
method = "KEGG",
filterP = "PVAL",
cutoff = 0.05,
ont = "BP",
pool = FALSE,
plot = TRUE,
plotType = "bar", # bar
plotcolor = "pvalue",
showCategory=10,
pvalueCutoff = 0.05,
pAdjustMethod = "BH",
qvalueCutoff = 0.2)
library(devtools)
setwd("D:/myweb/easyEWAS") # no web
load_all()
document()
setwd("D:/myweb/easyEWAS") # no web
load_all()
document()
detach("package:easyEWAS", unload = TRUE, character.only = TRUE)
remove.packages("easyEWAS")
remotes::install_github("ytwangZero/easyEWAS")
remotes::install_github("ytwangZero/easyEWAS")
