stopImplicitCluster()
spstopCluster(cl)
stopCluster(cl)
modelres = as.data.frame(modelres[1:len,])
modelres
rm(list = ls())
detach("package:easyEWAS", unload = TRUE, character.only = TRUE)
remove.packages("easyEWAS")
remotes::install_github("ytwangZero/easyEWAS")
remotes::install_github("ytwangZero/easyEWAS")
warnings()
library(easyEWAS)
library(tidyverse)
outpath = "D:/test"
ExpoPath = "D:/R/Rwork/Rhistory/shiny/testdata/sampledata.xlsx"
MethyPath = "D:/R/Rwork/Rhistory/shiny/testdata/methydata.xlsx"
res <- initEWAS(outpath = outpath)
res <- loadEWAS(input = res, ExpoPath =  ExpoPath, MethyPath = MethyPath)
res$Data$Expo
Vars = "sex,batch"
res <- transEWAS(res, Vars = Vars, TypeTo = "factor")
adjustVar = "sex,age"
batch = "batch"
plot = TRUE
par.prior = TRUE
mean.only = FALSE
ref.batch = NULL
parallel = FALSE
core = NULL
colnames(res$Data$Expo)
res <- batchEWAS(input = res, adjustVar = adjustVar,
batch = "batch", parallel = F, core = 1)
res$Data$Expo
input = res
filename ="default"
model = "lm"
expo = 'age'
cov = "sex,LYMPHPER,BMI"
cov = NULL
random = NULL
time = NULL
status = NULL
adjustP = TRUE
chipType = "EPICV2"
core = 6
res <- easyEWAS::startEWAS(res,
filename =filename,
model = model,
expo = expo,
cov = cov,
random = random,
time = time,
status = status,
adjustP = adjustP,
chipType = chipType,
core = core)
message("It will take some time, please be patient...")
# -------------------------------------------
# Set number of cores for parallel processing
# -------------------------------------------
if(core == "default"){
no_cores = detectCores(logical=F) - 1
}else{
no_cores = core
}
# -----------------------------
# Set exposure variable name
# -----------------------------
expo <- if (is.null(expo) || expo == "default") "var" else expo
# ----------------------------------------------------------
# Check if exposure is a factor and compute number of levels
# ----------------------------------------------------------
expo_vec <- unlist(input$Data$Expo[, expo])
facnum <- if (is.factor(expo_vec)) length(levels(expo_vec)) else 2
if (!is.factor(expo_vec) && model %in% c("lm", "lmer") && length(unique(expo_vec)) <= 4) {
warning(paste0("Exposure variable '", expo, "' is not a factor but has only ",
length(unique(expo_vec)), " unique values. ",
"If this is a categorical variable, please use transEWAS() to convert it."))
}
# ----------------------------------------------------------
# Define EWAS model fitting function based on selected model
# ----------------------------------------------------------
ewasfun <- function(cg, ff, cov) {
cov$cpg <- as.vector(t(cg))
res <- tryCatch({
if (model == "lm") {
out <- summary(lm(ff, data = cov))
unlist(lapply(2:facnum, function(i) out$coefficients[i, c(1, 2, 4)]))
} else if (model == "lmer") {
out <- summary(lmer(ff, data = cov))
unlist(lapply(2:facnum, function(i) out$coefficients[i, c(1, 2, 5)]))
} else if (model == "cox") {
out <- summary(coxph(ff, data = cov))
c(as.vector(out$conf.int[1, c(1, 3, 4)]), out$coefficients[1, 5])
} else {
stop("Unsupported model: ", model)
}
}, error = function(e) {
if (model %in% c("lm", "lmer")) return(rep(NA_real_, 3 * (facnum - 1)))
if (model == "cox") return(rep(NA_real_, 4))
})
return(res)
}
model -> input$model
# -----------------------------
# Prepare covariate data
# -----------------------------
VarCov <- if (!is.null(cov)) unlist(strsplit(cov, ",")) else character(0)
required_cols <- switch(model,
"lm"   = c(expo, VarCov),
"lmer" = c(expo, VarCov, random),
"cox"  = c(time, status, VarCov)
)
covdata <- input$Data$Expo[, required_cols, drop = FALSE]
# Rename variables based on model needs
if (model == "lmer") {
colnames(covdata)[match(random, colnames(covdata))] <- "random"
random_index <- which(colnames(covdata) == "random")
input$random <- random
} else if (model == "cox") {
colnames(covdata)[match(time, colnames(covdata))] <- "time"
colnames(covdata)[match(status, colnames(covdata))] <- "status"
input$time <- time
input$status <- status
}
input$covdata <- covdata
# -----------------------------
# Build model formula
# -----------------------------
formula <- switch (model,
"lm" = as.formula(paste0("cpg ~ ",paste(colnames(covdata), collapse = " + "))),
"lmer" = as.formula(paste0("cpg ~ ",paste(colnames(covdata)[-random_index], collapse = " + "), " + (1 | random)")),
"cox" = {
if(length(VarCov) > 0){
as.formula(paste0("Surv(time, status) ~ cpg + ", paste(VarCov, collapse = "+")))
}else{
as.formula("Surv(time, status) ~ cpg")
}
}
)
formula -> input$formula
# --------------------------------
# Extract methylation beta matrix
# --------------------------------
sample_names <- input$Data$Expo[[1]]
df_beta <- input$Data$Methy[, sample_names, drop = FALSE]
rownames(df_beta) <- input$Data$Methy[[1]]
# -----------------------------
# Set up parallel computation
# -----------------------------
message("Running parallel EWAS model fitting ...")
len = nrow(df_beta)
chunk.size <- ceiling(len/no_cores)
result_cols <- switch(model,
"lm" = 3 * (facnum - 1),
"lmer" = 3 * (facnum - 1),
"cox" = 4)
cl <- makeCluster(no_cores)
registerDoParallel(cl)
clusterExport(cl, varlist = c("ewasfun", "formula", "covdata", "df_beta", "facnum"), envir = environment())
if (model == "lmer") clusterEvalQ(cl, library(lmerTest))
if (model == "cox") clusterEvalQ(cl, library(survival))
# --------------------------------
# Run parallel EWAS model fitting
# --------------------------------
start_time <- Sys.time()
modelres <- foreach(i=1:no_cores, .combine='rbind') %dopar%
{
restemp <- matrix(0, nrow=min(chunk.size, len-(i-1)*chunk.size), ncol=result_cols)
for(x in ((i-1)*chunk.size+1):min(i*chunk.size, len)) {
restemp[x - (i-1)*chunk.size,] <- as.numeric(base::t(ewasfun(df_beta[x,],formula,covdata)))
}
restemp
}
end_time <- Sys.time()
stopImplicitCluster()
stopCluster(cl)
modelres = as.data.frame(modelres[1:len,])
message(sprintf("\n✓ Parallel EWAS model fitting completed in %.2f seconds.\n", as.numeric(difftime(end_time, start_time, units = "secs"))))
# -----------------------------
# Post-processing results
# -----------------------------
if((model %in% c("lmer","lm")) & class(unlist(input$Data$Expo[,expo])) == "factor"){
## categorical variable-----
colnames(modelres)[1:(3 * (facnum - 1))] <- paste0(
rep(c("BETA", "SE", "PVAL"), facnum - 1), "_", rep(1:(facnum - 1), each = 3)
)
modelres <- cbind(probe = rownames(df_beta), modelres)
## FDR pr Bonferroni adjustment---
if(adjustP){
message("Start multiple testing correction ...\n")
FDRname = paste(rep(c("FDR","Bonfferoni"),each = (facnum-1)),rep(1:(facnum-1),2), sep = "_")
pindex = grep("PVAL",colnames(modelres))
FDR = matrix(0,nrow = nrow(modelres),ncol = length(FDRname))
for(i in pindex){
FDR[,(i-1)/3] = p.adjust(modelres[[i]],method = "BH")
FDR[,((i-1)/3)+(facnum-1)] = p.adjust(modelres[[i]],method = "bonferroni")
}
FDR <- as.data.frame(FDR)
colnames(FDR) <- paste(rep(c("FDR", "Bonfferoni"), each = (facnum - 1)),
rep(1:(facnum - 1), 2), sep = "_")
modelres = cbind(modelres,FDR)
}
}else if((model %in% c("lmer","lm")) & class(unlist(input$Data$Expo[,expo])) != "factor"){
## continuous variable-----
names(modelres)[1:3] <- c("BETA", "SE", "PVAL")
modelres <- cbind(probe = rownames(df_beta), modelres)
## per SD & IQR---
modelres$BETA_perSD = (modelres$BETA)*(sd(covdata[[expo]],na.rm = TRUE))
modelres$BETA_perIQR = (modelres$BETA)*(IQR(covdata[[expo]],na.rm = TRUE))
modelres$SE_perSD = (modelres$SE)*(sd(covdata[[expo]],na.rm = TRUE))
modelres$SE_perIQR = (modelres$SE)*(IQR(covdata[[expo]],na.rm = TRUE))
modelres <- modelres[, c("probe", "BETA", "BETA_perSD", "BETA_perIQR",
"SE", "SE_perSD", "SE_perIQR", "PVAL")]
## FDR pr Bonferroni adjustment---
if(adjustP){
message("Start multiple testing correction ...\n")
modelres$FDR = p.adjust(modelres$PVAL, method = "BH")
modelres$Bonfferoni = p.adjust(modelres$PVAL,method = "bonferroni")
}
}else if(model == "cox"){
modelres <- as.data.frame(modelres)
colnames(modelres) <- c("HR", "LOWER_95%", "UPPER_95%", "PVAL")
modelres$probe <- rownames(df_beta)
modelres <- modelres[, c("probe", "HR", "LOWER_95%", "UPPER_95%", "PVAL")]
##  FDR pr Bonferroni adjustment---
if(adjustP){
message("Start multiple testing correction ...\n")
modelres$FDR = p.adjust(modelres$PVAL, method = "BH")
modelres$Bonfferoni = p.adjust(modelres$PVAL,method = "bonferroni")
}
}
# ---------------------------------
# Annotate CpG sites with chip info
# ---------------------------------
message("Start CpG sites annotation ...\n")
if (!is.null(chipType)) {
chipGenome <- switch(chipType,
"EPICV2" = "hg38 (GRCh38)",
"EPICV1" = "hg19 (GRCh37)",
"450K"   = "hg19 (GRCh37)",
"27K"    = "hg19 (GRCh37)",
"MSA"    = "hg19 (GRCh37)",
"Unknown genome"
)
message(sprintf("Using annotation for chip type: %s (Genome: %s)", chipType, chipGenome))
}
if(!is.null(chipType) & chipType == "EPICV2"){
colnames(annotationV2) = c("probe","chr","pos","relation_to_island","gene","location")
modelres %>%
left_join(annotationV2, by = "probe") -> modelres
}
if(!is.null(chipType) & chipType == "EPICV1"){
colnames(annotationV1) = c("probe","chr","pos","relation_to_island","gene","location")
modelres %>%
left_join(annotationV1, by = "probe") -> modelres
}
message("It will take some time, please be patient...")
# -------------------------------------------
# Set number of cores for parallel processing
# -------------------------------------------
if(core == "default"){
no_cores = detectCores(logical=F) - 1
}else{
no_cores = core
}
# -----------------------------
# Set exposure variable name
# -----------------------------
expo <- if (is.null(expo) || expo == "default") "var" else expo
# ----------------------------------------------------------
# Check if exposure is a factor and compute number of levels
# ----------------------------------------------------------
expo_vec <- unlist(input$Data$Expo[, expo])
facnum <- if (is.factor(expo_vec)) length(levels(expo_vec)) else 2
if (!is.factor(expo_vec) && model %in% c("lm", "lmer") && length(unique(expo_vec)) <= 4) {
warning(paste0("Exposure variable '", expo, "' is not a factor but has only ",
length(unique(expo_vec)), " unique values. ",
"If this is a categorical variable, please use transEWAS() to convert it."))
}
# ----------------------------------------------------------
# Define EWAS model fitting function based on selected model
# ----------------------------------------------------------
# 在并行循环外部定义函数所需的所有变量
model_type <- model
facnum_val <- facnum
# 重构后的 ewasfun，不依赖闭包环境
ewasfun_fixed <- function(cg, ff, cov_data, model, facnum) {
cov_data$cpg <- as.vector(t(cg))
tryCatch({
if (model == "lm") {
out <- summary(lm(ff, data = cov_data))
unlist(lapply(2:facnum, function(i) out$coefficients[i, c(1, 2, 4)]))
} else if (model == "lmer") {
out <- summary(lmerTest::lmer(ff, data = cov_data))
unlist(lapply(2:facnum, function(i) out$coefficients[i, c(1, 2, 5)]))
} else if (model == "cox") {
out <- summary(survival::coxph(ff, data = cov_data))
c(as.vector(out$conf.int[1, c(1, 3, 4)]), out$coefficients[1, 5])
} else {
rep(NA_real_, ifelse(model == "cox", 4, 3 * (facnum - 1)))
}
}, error = function(e) {
if (model %in% c("lm", "lmer")) return(rep(NA_real_, 3 * (facnum - 1)))
if (model == "cox") return(rep(NA_real_, 4))
})
}
model -> input$model
# -----------------------------
# Prepare covariate data
# -----------------------------
VarCov <- if (!is.null(cov)) unlist(strsplit(cov, ",")) else character(0)
required_cols <- switch(model,
"lm"   = c(expo, VarCov),
"lmer" = c(expo, VarCov, random),
"cox"  = c(time, status, VarCov)
)
covdata <- input$Data$Expo[, required_cols, drop = FALSE]
# Rename variables based on model needs
if (model == "lmer") {
colnames(covdata)[match(random, colnames(covdata))] <- "random"
random_index <- which(colnames(covdata) == "random")
input$random <- random
} else if (model == "cox") {
colnames(covdata)[match(time, colnames(covdata))] <- "time"
colnames(covdata)[match(status, colnames(covdata))] <- "status"
input$time <- time
input$status <- status
}
input$covdata <- covdata
# -----------------------------
# Build model formula
# -----------------------------
formula <- switch (model,
"lm" = as.formula(paste0("cpg ~ ",paste(colnames(covdata), collapse = " + "))),
"lmer" = as.formula(paste0("cpg ~ ",paste(colnames(covdata)[-random_index], collapse = " + "), " + (1 | random)")),
"cox" = {
if(length(VarCov) > 0){
as.formula(paste0("Surv(time, status) ~ cpg + ", paste(VarCov, collapse = "+")))
}else{
as.formula("Surv(time, status) ~ cpg")
}
}
)
formula -> input$formula
# --------------------------------
# Extract methylation beta matrix
# --------------------------------
sample_names <- input$Data$Expo[[1]]
df_beta <- input$Data$Methy[, sample_names, drop = FALSE]
rownames(df_beta) <- input$Data$Methy[[1]]
# -----------------------------
# Set up parallel computation
# -----------------------------
# --------------------------------
# 设置并行环境 (关键修复)
# --------------------------------
message("Running parallel EWAS model fitting ...")
len <- nrow(df_beta)
chunk.size <- ceiling(len / no_cores)
result_cols <- switch(model,
"lm" = 3 * (facnum - 1),
"lmer" = 3 * (facnum - 1),
"cox" = 4)
# 创建集群并确保关闭
cl <- parallel::makeCluster(no_cores)
on.exit({
try(parallel::stopCluster(cl), silent = TRUE)
if (foreach::getDoParRegistered()) {
try(doParallel::stopImplicitCluster(), silent = TRUE)
}
}, add = TRUE)
doParallel::registerDoParallel(cl)
# 显式导出必要的最小对象集
parallel::clusterExport(cl, varlist = c("model_type", "facnum_val"),
envir = environment())
# 在工作节点加载所需包
if (model_type == "lmer") {
parallel::clusterEvalQ(cl, {
library(lmerTest, quietly = TRUE)
library(lme4, quietly = TRUE)
})
} else if (model_type == "cox") {
parallel::clusterEvalQ(cl, library(survival, quietly = TRUE))
}
# 优化后的并行计算
start_time <- Sys.time()
modelres <- foreach::foreach(i = 1:no_cores, .combine = 'rbind') %dopar% {
# 计算当前分块的索引范围
start_idx <- (i - 1) * chunk.size + 1
end_idx <- min(i * chunk.size, len)
chunk_len <- end_idx - start_idx + 1
# 预分配结果矩阵
restemp <- matrix(0, nrow = chunk_len, ncol = result_cols)
# 处理当前分块
for (k in 1:chunk_len) {
row_index <- start_idx + k - 1
restemp[k, ] <- as.numeric(t(ewasfun_fixed(
df_beta[row_index, ],
formula,
covdata,
model_type,
facnum_val
)))
}
restemp
}
end_time <- Sys.time()
stopImplicitCluster()
stopCluster(cl)
modelres = as.data.frame(modelres[1:len,])
message(sprintf("\n✓ Parallel EWAS model fitting completed in %.2f seconds.\n", as.numeric(difftime(end_time, start_time, units = "secs"))))
rm(list = ls())
detach("package:easyEWAS", unload = TRUE, character.only = TRUE)
remove.packages("easyEWAS")
remotes::install_github("ytwangZero/easyEWAS")
library(easyEWAS)
library(tidyverse)
outpath = "D:/test"
ExpoPath = "D:/R/Rwork/Rhistory/shiny/testdata/sampledata.xlsx"
MethyPath = "D:/R/Rwork/Rhistory/shiny/testdata/methydata.xlsx"
res <- initEWAS(outpath = outpath)
res <- loadEWAS(input = res, ExpoPath =  ExpoPath, MethyPath = MethyPath)
res$Data$Expo
Vars = "sex,batch"
res <- transEWAS(res, Vars = Vars, TypeTo = "factor")
adjustVar = "sex,age"
batch = "batch"
plot = TRUE
par.prior = TRUE
mean.only = FALSE
ref.batch = NULL
parallel = FALSE
core = NULL
colnames(res$Data$Expo)
res <- batchEWAS(input = res, adjustVar = adjustVar,
batch = "batch", parallel = F, core = 1)
res$Data$Expo
input = res
filename ="default"
model = "lm"
expo = 'age'
cov = "sex,LYMPHPER,BMI"
cov = NULL
random = NULL
time = NULL
status = NULL
adjustP = TRUE
chipType = "EPICV2"
core = 6
res <- easyEWAS::startEWAS(res,
filename =filename,
model = model,
expo = expo,
cov = cov,
random = random,
time = time,
status = status,
adjustP = adjustP,
chipType = chipType,
core = core)
stopImplicitCluster()
stopCluster(cl)
detach("package:easyEWAS", unload = TRUE, character.only = TRUE)
remove.packages("easyEWAS")
remotes::install_github("ytwangZero/easyEWAS")
library(easyEWAS)
library(tidyverse)
rm(list = ls())
outpath = "D:/test"
ExpoPath = "D:/R/Rwork/Rhistory/shiny/testdata/sampledata.xlsx"
MethyPath = "D:/R/Rwork/Rhistory/shiny/testdata/methydata.xlsx"
res <- initEWAS(outpath = outpath)
res <- loadEWAS(input = res, ExpoPath =  ExpoPath, MethyPath = MethyPath)
res$Data$Expo
Vars = "sex,batch"
res <- transEWAS(res, Vars = Vars, TypeTo = "factor")
adjustVar = "sex,age"
batch = "batch"
plot = TRUE
par.prior = TRUE
mean.only = FALSE
ref.batch = NULL
parallel = FALSE
core = NULL
colnames(res$Data$Expo)
res <- batchEWAS(input = res, adjustVar = adjustVar,
batch = "batch", parallel = F, core = 1)
res$Data$Expo
input = res
filename ="default"
model = "lm"
expo = 'age'
cov = "sex,LYMPHPER,BMI"
cov = NULL
random = NULL
time = NULL
status = NULL
adjustP = TRUE
chipType = "EPICV2"
core = 6
res <- easyEWAS::startEWAS(res,
filename =filename,
model = model,
expo = expo,
cov = cov,
random = random,
time = time,
status = status,
adjustP = adjustP,
chipType = chipType,
core = core)
