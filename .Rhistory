}
# -----------------------------
# Set exposure variable name
# -----------------------------
expo <- if (is.null(expo) || expo == "default") "var" else expo
# ----------------------------------------------------------
# Check if exposure is a factor and compute number of levels
# ----------------------------------------------------------
expo_vec <- unlist(input$Data$Expo[, expo])
facnum <- if (is.factor(expo_vec)) length(levels(expo_vec)) else 2
if (!is.factor(expo_vec) && model %in% c("lm", "lmer") && length(unique(expo_vec)) <= 4) {
warning(paste0("Exposure variable '", expo, "' is not a factor but has only ",
length(unique(expo_vec)), " unique values. ",
"If this is a categorical variable, please use transEWAS() to convert it."))
}
# ----------------------------------------------------------
# Define EWAS model fitting function based on selected model
# ----------------------------------------------------------
ewasfun <- function(cg, ff, cov) {
cov$cpg <- as.vector(t(cg))
res <- tryCatch({
if (model == "lm") {
out <- summary(lm(ff, data = cov))
unlist(lapply(2:facnum, function(i) out$coefficients[i, c(1, 2, 4)]))
} else if (model == "lmer") {
out <- summary(lmer(ff, data = cov))
unlist(lapply(2:facnum, function(i) out$coefficients[i, c(1, 2, 5)]))
} else if (model == "cox") {
out <- summary(coxph(ff, data = cov))
c(as.vector(out$conf.int[1, c(1, 3, 4)]), out$coefficients[1, 5])
} else {
stop("Unsupported model: ", model)
}
}, error = function(e) {
if (model %in% c("lm", "lmer")) return(rep(NA_real_, 3 * (facnum - 1)))
if (model == "cox") return(rep(NA_real_, 4))
})
return(res)
}
model -> input$model
# -----------------------------
# Prepare covariate data
# -----------------------------
VarCov <- if (!is.null(cov)) unlist(strsplit(cov, ",")) else character(0)
required_cols <- switch(model,
"lm"   = c(expo, VarCov),
"lmer" = c(expo, VarCov, random),
"cox"  = c(time, status, VarCov)
)
covdata <- input$Data$Expo[, required_cols, drop = FALSE]
# Rename variables based on model needs
if (model == "lmer") {
colnames(covdata)[match(random, colnames(covdata))] <- "random"
random_index <- which(colnames(covdata) == "random")
input$random <- random
} else if (model == "cox") {
colnames(covdata)[match(time, colnames(covdata))] <- "time"
colnames(covdata)[match(status, colnames(covdata))] <- "status"
input$time <- time
input$status <- status
}
input$covdata <- covdata
# -----------------------------
# Build model formula
# -----------------------------
formula <- switch (model,
"lm" = as.formula(paste0("cpg ~ ",paste(colnames(covdata), collapse = " + "))),
"lmer" = as.formula(paste0("cpg ~ ",paste(colnames(covdata)[-random_index], collapse = " + "), " + (1 | random)")),
"cox" = {
if(length(VarCov) > 0){
as.formula(paste0("Surv(time, status) ~ cpg + ", paste(VarCov, collapse = "+")))
}else{
as.formula("Surv(time, status) ~ cpg")
}
}
)
formula -> input$formula
# --------------------------------
# Extract methylation beta matrix
# --------------------------------
sample_names <- input$Data$Expo[[1]]
df_beta <- input$Data$Methy[, sample_names, drop = FALSE]
rownames(df_beta) <- input$Data$Methy[[1]]
preprocess_end_time <- Sys.time()
message("✓ EWAS data preprocessing completed in ", round(preprocess_end_time - preprocess_start_time, 2), " seconds.\n")
# -----------------------------
# Set up parallel computation
# -----------------------------
message("Starting parallel computation setup ...")
len = nrow(df_beta)
chunk.size <- ceiling(len/no_cores)
result_cols <- switch(model,
"lm" = 3 * (facnum - 1),
"lmer" = 3 * (facnum - 1),
"cox" = 4)
setup_time <- system.time({
cl <- makeCluster(no_cores)
registerDoParallel(cl)
clusterExport(cl, varlist = c("ewasfun", "formula", "covdata", "df_beta", "facnum"), envir = environment())
if (model == "lmer") clusterEvalQ(cl, library(lmerTest))
if (model == "cox") clusterEvalQ(cl, library(survival))
})["elapsed"]
message("✓ Parallel setup completed in ", round(setup_time, 2), " seconds.\n")
# --------------------------------
# Run parallel EWAS model fitting
# --------------------------------
message("Running parallel EWAS model fitting ...")
# --------------------------------
# Run parallel EWAS model fitting
# --------------------------------
message("Running parallel EWAS model fitting ...")
ewas_start_time <- Sys.time()
modelres <- foreach(i=1:no_cores, .combine='rbind') %dopar%
{
restemp <- matrix(0, nrow=min(chunk.size, len-(i-1)*chunk.size), ncol=result_cols)
for(x in ((i-1)*chunk.size+1):min(i*chunk.size, len)) {
restemp[x - (i-1)*chunk.size,] <- as.numeric(base::t(ewasfun(df_beta[x,],formula,covdata)))
}
restemp
}
stopImplicitCluster()
stopCluster(cl)
modelres = as.data.frame(modelres[1:len,])
ewas_end_time <- Sys.time()
message(sprintf("✓ Parallel EWAS model fitting completed in %.2f seconds.\n", as.numeric(difftime(ewas_end_time, ewas_start_time, units = "secs"))))
# -----------------------------
# Post-processing results
# -----------------------------
if((model %in% c("lmer","lm")) & class(unlist(input$Data$Expo[,expo])) == "factor"){
## categorical variable-----
colnames(modelres)[1:(3 * (facnum - 1))] <- paste0(
rep(c("BETA", "SE", "PVAL"), facnum - 1), "_", rep(1:(facnum - 1), each = 3)
)
modelres <- cbind(probe = rownames(df_beta), modelres)
## FDR pr Bonferroni adjustment---
if(adjustP){
FDRname = paste(rep(c("FDR","Bonfferoni"),each = (facnum-1)),rep(1:(facnum-1),2), sep = "_")
pindex = grep("PVAL",colnames(modelres))
FDR = matrix(0,nrow = nrow(modelres),ncol = length(FDRname))
for(i in pindex){
FDR[,(i-1)/3] = p.adjust(modelres[[i]],method = "BH")
FDR[,((i-1)/3)+(facnum-1)] = p.adjust(modelres[[i]],method = "bonferroni")
}
FDR <- as.data.frame(FDR)
colnames(FDR) <- paste(rep(c("FDR", "Bonfferoni"), each = (facnum - 1)),
rep(1:(facnum - 1), 2), sep = "_")
modelres = cbind(modelres,FDR)
message("✓ Multiple testing correction completed!\n")
}
}else if((model %in% c("lmer","lm")) & class(unlist(input$Data$Expo[,expo])) != "factor"){
## continuous variable-----
names(modelres)[1:3] <- c("BETA", "SE", "PVAL")
modelres <- cbind(probe = rownames(df_beta), modelres)
## per SD & IQR---
modelres$BETA_perSD = (modelres$BETA)*(sd(covdata[[expo]],na.rm = TRUE))
modelres$BETA_perIQR = (modelres$BETA)*(IQR(covdata[[expo]],na.rm = TRUE))
modelres$SE_perSD = (modelres$SE)*(sd(covdata[[expo]],na.rm = TRUE))
modelres$SE_perIQR = (modelres$SE)*(IQR(covdata[[expo]],na.rm = TRUE))
modelres <- modelres[, c("probe", "BETA", "BETA_perSD", "BETA_perIQR",
"SE", "SE_perSD", "SE_perIQR", "PVAL")]
## FDR pr Bonferroni adjustment---
if(adjustP){
modelres$FDR = p.adjust(modelres$PVAL, method = "BH")
modelres$Bonfferoni = p.adjust(modelres$PVAL,method = "bonferroni")
message("✓ Multiple testing correction completed!\n")
}
}else if(model == "cox"){
modelres <- as.data.frame(modelres)
colnames(modelres) <- c("HR", "LOWER_95%", "UPPER_95%", "PVAL")
modelres$probe <- rownames(df_beta)
modelres <- modelres[, c("probe", "HR", "LOWER_95%", "UPPER_95%", "PVAL")]
##  FDR pr Bonferroni adjustment---
if(adjustP){
modelres$FDR = p.adjust(modelres$PVAL, method = "BH")
modelres$Bonfferoni = p.adjust(modelres$PVAL,method = "bonferroni")
message("✓ Multiple testing correction completed!\n")
}
}
# ---------------------------------
# Annotate CpG sites with chip info
# ---------------------------------
message("Start CpG sites annotation ...")
# --------------------------------
# Run parallel EWAS model fitting
# --------------------------------
message("Running parallel EWAS model fitting ...")
ewas_start_time <- Sys.time()
modelres <- foreach(i=1:no_cores, .combine='rbind') %dopar%
{
restemp <- matrix(0, nrow=min(chunk.size, len-(i-1)*chunk.size), ncol=result_cols)
for(x in ((i-1)*chunk.size+1):min(i*chunk.size, len)) {
restemp[x - (i-1)*chunk.size,] <- as.numeric(base::t(ewasfun(df_beta[x,],formula,covdata)))
}
restemp
}
setup_time <- system.time({
cl <- makeCluster(no_cores)
registerDoParallel(cl)
clusterExport(cl, varlist = c("ewasfun", "formula", "covdata", "df_beta", "facnum"), envir = environment())
if (model == "lmer") clusterEvalQ(cl, library(lmerTest))
if (model == "cox") clusterEvalQ(cl, library(survival))
})["elapsed"]
message("✓ Parallel setup completed in ", round(setup_time, 2), " seconds.\n")
# --------------------------------
# Run parallel EWAS model fitting
# --------------------------------
message("Running parallel EWAS model fitting ...")
ewas_start_time <- Sys.time()
modelres <- foreach(i=1:no_cores, .combine='rbind') %dopar%
{
restemp <- matrix(0, nrow=min(chunk.size, len-(i-1)*chunk.size), ncol=result_cols)
for(x in ((i-1)*chunk.size+1):min(i*chunk.size, len)) {
restemp[x - (i-1)*chunk.size,] <- as.numeric(base::t(ewasfun(df_beta[x,],formula,covdata)))
}
restemp
}
stopImplicitCluster()
stopCluster(cl)
modelres = as.data.frame(modelres[1:len,])
ewas_end_time <- Sys.time()
message(sprintf("✓ Parallel EWAS model fitting completed in %.2f seconds.\n", as.numeric(difftime(ewas_end_time, ewas_start_time, units = "secs"))))
# -----------------------------
# Set up parallel computation
# -----------------------------
message("Starting parallel computation setup ...")
len = nrow(df_beta)
chunk.size <- ceiling(len/no_cores)
result_cols <- switch(model,
"lm" = 3 * (facnum - 1),
"lmer" = 3 * (facnum - 1),
"cox" = 4)
setup_time <- system.time({
cl <- makeCluster(no_cores)
registerDoParallel(cl)
if (model == "lm") {
clusterExport(cl, varlist = "ewasfun_lm", envir = asNamespace("easyEWAS"))
} else if (model == "lmer") {
clusterEvalQ(cl, library(lmerTest))
clusterExport(cl, varlist = "ewasfun_lmer", envir = asNamespace("easyEWAS"))
} else if (model == "cox") {
clusterEvalQ(cl, library(survival))
clusterExport(cl, varlist = "ewasfun_cox", envir = asNamespace("easyEWAS"))
}
})["elapsed"]
message("Parallel setup completed in ", round(setup_time, 2), " seconds.\n")
# --------------------------------
# Run parallel EWAS model fitting
# --------------------------------
message("Running parallel EWAS model fitting ...")
ewas_start_time <- Sys.time()
modelres <- foreach(i=1:no_cores, .combine='rbind', .errorhandling = "pass") %dopar%
{
restemp <- matrix(0, nrow=min(chunk.size, len-(i-1)*chunk.size), ncol=result_cols)
for(x in ((i-1)*chunk.size+1):min(i*chunk.size, len)) {
restemp[x - (i-1)*chunk.size,] <- as.numeric(
t(if (model == "lm") {
ewasfun_lm(df_beta[x, ], formula, covdata, facnum)
} else if (model == "lmer") {
ewasfun_lmer(df_beta[x, ], formula, covdata, facnum)
} else if (model == "cox") {
ewasfun_cox(df_beta[x, ], formula, covdata)
})
)
}
restemp
}
stopImplicitCluster()
stopCluster(cl)
modelres = as.data.frame(modelres[1:len,])
ewas_end_time <- Sys.time()
message(sprintf("Parallel EWAS model fitting completed in %.2f seconds.\n", as.numeric(difftime(ewas_end_time, ewas_start_time, units = "secs"))))
rm(list = ls())
detach("package:easyEWAS", unload = TRUE, character.only = TRUE)
rm(list = ls())
source("D:/myweb/easyEWAS/R/initEWAS.R")
source("D:/myweb/easyEWAS/R/loadEWAS.R")
source("D:/myweb/easyEWAS/R/transEWAS.R")
source("D:/myweb/easyEWAS/R/batchEWAS.R")
source("D:/myweb/easyEWAS/R/startEWAS.R")
source("D:/myweb/easyEWAS/R/ewasfun_utils.R")
outpath = "D:/test"
ExpoPath = "D:/R/Rwork/Rhistory/shiny/testdata/sampledata.xlsx"
MethyPath = "D:/R/Rwork/Rhistory/shiny/testdata/methydata.xlsx"
res <- initEWAS(outpath = outpath)
res <- loadEWAS(input = res, ExpoPath =  ExpoPath, MethyPath = MethyPath)
Vars = "sex,batch"
res <- transEWAS(res, Vars = Vars, TypeTo = "factor")
adjustVar = "sex,age"
batch = "batch"
plot = TRUE
par.prior = TRUE
mean.only = FALSE
ref.batch = NULL
parallel = FALSE
core = NULL
colnames(res$Data$Expo)
res <- batchEWAS(input = res, adjustVar = adjustVar,
batch = "batch", parallel = F, core = 1)
# res$Data$Expo
input = res
filename ="default"
model = "lm"
expo = 'age'
cov = "sex,BMI"
random = NULL
time = NULL
status = NULL
adjustP = TRUE
chipType = "EPICV2"
core = 10
res <- startEWAS(res,
filename =filename,
model = model,
expo = expo,
cov = cov,
random = random,
time = time,
status = status,
adjustP = adjustP,
chipType = chipType,
core = core)
setwd("D:/AtPKUlife/01课题组工作/01项目合作/R包优化")
source("D:/AtPKUlife/01课题组工作/01项目合作/R包优化/startEWAS_v0.R")
res <- startEWAS_v0(res,
filename =filename,
model = model,
expo = expo,
cov = cov,
random = random,
time = time,
status = status,
adjustP = adjustP,
chipType = chipType,
core = core)
source("D:/AtPKUlife/01课题组工作/01项目合作/R包优化/startEWAS_v0.R")
res <- startEWAS_v0(res,
filename =filename,
model = model,
expo = expo,
cov = cov,
random = random,
time = time,
status = status,
adjustP = adjustP,
chipType = chipType,
core = core)
source("D:/AtPKUlife/01课题组工作/01项目合作/R包优化/startEWAS_v0.R")
res <- startEWAS(res,
filename =filename,
model = model,
expo = expo,
cov = cov,
random = random,
time = time,
status = status,
adjustP = adjustP,
chipType = chipType,
core = core)
res$Data$Expo
res <- plotEWAS(res)
source("D:/myweb/easyEWAS/R/plotEWAS.R")
res <- plotEWAS(res)
res <- plotEWAS(input = res)
rm(list = ls())
source("D:/myweb/easyEWAS/R/initEWAS.R")
source("D:/myweb/easyEWAS/R/loadEWAS.R")
source("D:/myweb/easyEWAS/R/transEWAS.R")
source("D:/myweb/easyEWAS/R/batchEWAS.R")
source("D:/myweb/easyEWAS/R/startEWAS.R")
source("D:/myweb/easyEWAS/R/ewasfun_utils.R")
source("D:/AtPKUlife/01课题组工作/01项目合作/R包优化/startEWAS_v0.R")
source("D:/myweb/easyEWAS/R/plotEWAS.R")
outpath = "D:/test"
ExpoPath = "D:/R/Rwork/Rhistory/shiny/testdata/sampledata.xlsx"
MethyPath = "D:/R/Rwork/Rhistory/shiny/testdata/methydata.xlsx"
res <- initEWAS(outpath = outpath)
res <- loadEWAS(input = res, ExpoPath =  ExpoPath, MethyPath = MethyPath)
Vars = "sex,batch"
res <- transEWAS(res, Vars = Vars, TypeTo = "factor")
adjustVar = "sex,age"
batch = "batch"
plot = TRUE
par.prior = TRUE
mean.only = FALSE
ref.batch = NULL
parallel = FALSE
core = NULL
colnames(res$Data$Expo)
res <- batchEWAS(input = res, adjustVar = adjustVar,
batch = "batch", parallel = F, core = 1)
# res$Data$Expo
input = res
filename ="default"
model = "lm"
expo = 'age'
cov = "sex,BMI"
random = NULL
time = NULL
status = NULL
adjustP = TRUE
chipType = "EPICV2"
core = 10
res <- startEWAS(input = res,
filename =filename,
model = model,
expo = expo,
cov = cov,
random = random,
time = time,
status = status,
adjustP = adjustP,
chipType = chipType,
core = core)
res <- easyEWAS::startEWAS(input = res,
filename =filename,
model = model,
expo = expo,
cov = cov,
random = random,
time = time,
status = status,
adjustP = adjustP,
chipType = chipType,
core = core)
colnames(res$result)
input = res
p = "PVAL"
threshold=NULL
file=c("jpg","pdf","tiff","png")
col=c("#4197d8","#f8c120","#413496","#495226","#d60b6f",
"#e66519","#d581b7","#83d3ad","#7c162c","#26755d")
bin.size=1e6
bin.breaks=NULL
LOG10=TRUE
pch=19
type="p"
band=1
H=1.5
ylim=NULL
axis.cex=1
axis.lwd=1.5
lab.cex=1.5
lab.font=2
plot.type=c("m","c","q","d")
multracks=FALSE
multracks.xaxis=FALSE
multraits=FALSE
points.alpha=100L
r=0.3
cex=c(0.5,1,1)
outward=FALSE
ylab=expression(-log[10](italic(p)))
ylab.pos=3
xticks.pos=1
mar=c(3,6,3,3)
mar.between=0
threshold.col="red"
threshold.lwd=1
threshold.lty=2
amplify=FALSE
signal.cex=1.5
signal.pch=19
signal.col=NULL
signal.line=2
highlight=NULL
highlight.cex=1
highlight.pch=19
highlight.type="p"
highlight.col="red"
highlight.text=NULL
highlight.text.col="black"
highlight.text.cex=1
highlight.text.font=3
chr.labels=NULL
chr.border=FALSE
chr.labels.angle=0
chr.den.col="black"
chr.pos.max=FALSE
cir.band=1
cir.chr=TRUE
cir.chr.h=1.5
cir.axis=TRUE
cir.axis.col="black"
cir.axis.grid=TRUE
conf.int=TRUE
conf.int.col=NULL
file.output=TRUE
file.name=""
dpi=300
height=NULL
width=NULL
main=""
main.cex=1.5
main.font=2
legend.ncol=NULL
legend.cex=1
legend.pos=c("left","middle","right")
box=FALSE
verbose=FALSE
res <- plotEWAS(input = res)
setwd("D:/myweb/easyEWAS/R")
?CMplot::CMplot
detach("package:easyEWAS", unload = TRUE, character.only = TRUE)
remove.packages("easyEWAS")
remotes::install_github("ytwangZero/easyEWAS")
?easyEWAS::plotEWAS
setwd("D:/myweb/easyEWAS") # no web
load_all()
document()
library(devtools)
load_all()
document()
