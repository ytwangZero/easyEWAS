out <- tryCatch(summary(lm(ff, data = cov)), error = function(e) return(NA))
if (is.na(out)) return(rep(NA, 3 * (facnum - 1)))
unlist(lapply(2:facnum, function(i) out$coefficients[i, c(1, 2, 4)]))
}
extract_lmer_results <- function(cg, ff, cov, facnum) {
cov$cpg <- as.vector(t(cg))
out <- tryCatch(summary(lmer(ff, data = cov)), error = function(e) return(NA))
if (is.na(out)) return(rep(NA, 3 * (facnum - 1)))
unlist(lapply(2:facnum, function(i) out$coefficients[i, c(1, 2, 5)]))
}
extract_cox_results <- function(cg, ff, cov) {
cov$cpg <- as.vector(t(cg))
out <- tryCatch(summary(coxph(ff, data = cov)), error = function(e) return(NA))
if (is.na(out)) return(rep(NA, 4))
c(as.vector(out$conf.int[1, c(1, 3, 4)]), out$coefficients[1, 5])
}
ewasfun <- switch(model,
"lm"   = function(cg, ff, cov) extract_lm_results(cg, ff, cov, facnum),
"lmer" = function(cg, ff, cov) extract_lmer_results(cg, ff, cov, facnum),
"cox"  = extract_cox_results
)
model -> input$model
ewasfun
res$Data$Expo
cov = "sex,LYMPHPER,BMI"
## set ewas parameter
VarCov <- if (!is.null(cov)) unlist(strsplit(cov, ",")) else character(0)
VarCov
required_cols <- switch(model,
"lm"   = c(expo, VarCov),
"lmer" = c(expo, VarCov, random),
"cox"  = c(time, status, VarCov)
)
required_cols
covdata <- input$Data$Expo[, required_cols, drop = FALSE]
covdata
cov = NULL
cov = NULL
## set ewas parameter
VarCov <- if (!is.null(cov)) unlist(strsplit(cov, ",")) else character(0)
VarCov
required_cols <- switch(model,
"lm"   = c(expo, VarCov),
"lmer" = c(expo, VarCov, random),
"cox"  = c(time, status, VarCov)
)
covdata <- input$Data$Expo[, required_cols, drop = FALSE]
covdata
cov = "sex,LYMPHPER,BMI"
## set ewas parameter
VarCov <- if (!is.null(cov)) unlist(strsplit(cov, ",")) else character(0)
required_cols <- switch(model,
"lm"   = c(expo, VarCov),
"lmer" = c(expo, VarCov, random),
"cox"  = c(time, status, VarCov)
)
covdata <- input$Data$Expo[, required_cols, drop = FALSE]
length(VarCov) > 0
tt = character(0)
exists(tt)
exists("tt")
library(future)
library(future.apply)
library(progressr)
## set parallel parameters----
plan(multisession, workers = no_cores)
handlers("txtprogressbar")
len <- nrow(df_beta)
df_beta <- input$Data$Methy[, sample_names, drop = FALSE]
sample_names <- input$Data$Expo[[1]]
df_beta <- input$Data$Methy[, sample_names, drop = FALSE]
rownames(df_beta) <- input$Data$Methy[[1]]
## set parallel parameters----
plan(multisession, workers = no_cores)
handlers("txtprogressbar")
len <- nrow(df_beta)
result_cols <- switch(model,
"lm"   = 3 * (facnum - 1),
"lmer" = 3 * (facnum - 1),
"cox"  = 4
)
# start parallel computing ----
message("Start the EWAS analysis...")
with_progress({
p <- progressor(steps = len)
modelres <- future_lapply(1:len, FUN = function(i) {
beta_row <- df_beta[i, , drop = FALSE]
res <- tryCatch(
as.numeric(base::t(ewasfun(beta_row, formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
p()  # undata progress bar
res
},
future.seed = TRUE,
future.globals = list(ewasfun = ewasfun, formula = formula, covdata = covdata, df_beta = df_beta)
)
})
result_cols
with_progress({
p <- progressor(steps = len)
modelres <- future_lapply(1:len, FUN = function(i) {
beta_row <- df_beta[i, , drop = FALSE]
res <- tryCatch(
as.numeric(base::t(ewasfun(beta_row, formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
p()  # undata progress bar
res
},
future.seed = TRUE,
future.globals = list(
ewasfun = ewasfun,
formula = formula,
covdata = covdata,
df_beta = df_beta,
result_cols = result_cols)
)
})
with_progress({
p <- progressor(steps = len)
modelres <- future_lapply(1:len, FUN = function(i, p_func) {
beta_row <- df_beta[i, , drop = FALSE]
res <- tryCatch(
as.numeric(base::t(ewasfun(beta_row, formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
p_func()  # ✅ 调用传入的 p()
res
},
future.seed = TRUE,
future.globals = list(
ewasfun = ewasfun,
formula = formula,
covdata = covdata,
df_beta = df_beta,
result_cols = result_cols,
p_func = p  # ✅ 显式传递 p()
))
})
## set parallel parameters----
message("Start the EWAS analysis...")
len = nrow(df_beta)
chunk.size <- ceiling(len/no_cores)
result_cols <- switch(model,
"lm" = 3 * (facnum - 1),
"lmer" = 3 * (facnum - 1),
"cox" = 4
) # identify number of columns that each model returns
cl <- makeCluster(no_cores)
library(parallel)
library(foreach)
library(doParallel)
## set parallel parameters----
message("Start the EWAS analysis...")
len = nrow(df_beta)
chunk.size <- ceiling(len/no_cores)
result_cols <- switch(model,
"lm" = 3 * (facnum - 1),
"lmer" = 3 * (facnum - 1),
"cox" = 4
) # identify number of columns that each model returns
cl <- makeCluster(no_cores)
registerDoParallel(cl)
clusterExport(cl, varlist = c("ewasfun", "formula", "covdata", "df_beta", "facnum"), envir = environment())
if (model == "lmer") clusterEvalQ(cl, library(lmerTest))
if (model == "cox") clusterEvalQ(cl, library(survival))
## parallel computing-------
if(model %in% c("lm","lmer")){
system.time(
modelres <- foreach(i=1:no_cores, .combine='rbind') %dopar%
{  # local data for results
restemp <- matrix(0, nrow=min(chunk.size, len-(i-1)*chunk.size), ncol=3*(facnum-1))
for(x in ((i-1)*chunk.size+1):min(i*chunk.size, len)) {
restemp[x - (i-1)*chunk.size,] <- as.numeric(base::t(ewasfun(df_beta[x,],formula,covdata)))
}
# return local results
restemp
}
)
}else{
system.time(
modelres <- foreach(i=1:no_cores, .combine='rbind') %dopar%
{  # local data for results
restemp <- matrix(0, nrow=min(chunk.size, len-(i-1)*chunk.size), ncol=4)
for(x in ((i-1)*chunk.size+1):min(i*chunk.size, len)) {
restemp[x - (i-1)*chunk.size,] <- as.numeric(base::t(ewasfun(df_beta[x,],formula,covdata)))
}
# return local results
restemp
}
)
}
stopImplicitCluster()
stopCluster(cl)
modelres = modelres[1:len,]
source("D:/myweb/easyEWAS/R/startEWAS.R")
res$Data$Expo
filename ="default"
model = "lm"
expo = 'age'
cov = "sex,LYMPHPER,BMI"
cov = NULL
random = NULL
time = NULL
status = NULL
adjustP = TRUE
chipType = "EPICV2"
core = 6
res <- startEWAS(res,
filename =filename,
model = model,
expo = expo,
cov = cov,
random = random,
time = time,
status = status,
adjustP = adjustP,
chipType = chipType,
core = core)
filename ="default"
model = "lm"
expo = 'age'
cov = "sex,LYMPHPER,BMI"
cov = NULL
random = NULL
time = NULL
status = NULL
adjustP = TRUE
chipType = "EPICV2"
input = res
message("It will take some time, please be patient...")
# select number of cores
if(core == "default"){
no_cores = detectCores(logical=F) - 1
}else{
no_cores = core
}
expo <- if (is.null(expo) || expo == "default") "var" else expo
# peform EWAS analysis--------------------------------------------------------
## calculate factor number
expo_vec <- unlist(input$Data$Expo[, expo])
facnum <- if (is.factor(expo_vec)) length(levels(expo_vec)) else 2
if (!is.factor(expo_vec) && model %in% c("lm", "lmer") && length(unique(expo_vec)) <= 4) {
warning(paste0("Exposure variable '", expo, "' is not a factor but has only ",
length(unique(expo_vec)), " unique values. ",
"If this is a categorical variable, please use transEWAS() to convert it."))
}
## define ewas function-----
extract_lm_results <- function(cg, ff, cov, facnum) {
cov$cpg <- as.vector(t(cg))
out <- tryCatch(summary(lm(ff, data = cov)), error = function(e) return(NA))
if (is.na(out)) return(rep(NA, 3 * (facnum - 1)))
unlist(lapply(2:facnum, function(i) out$coefficients[i, c(1, 2, 4)]))
}
extract_lmer_results <- function(cg, ff, cov, facnum) {
cov$cpg <- as.vector(t(cg))
out <- tryCatch(summary(lmer(ff, data = cov)), error = function(e) return(NA))
if (is.na(out)) return(rep(NA, 3 * (facnum - 1)))
unlist(lapply(2:facnum, function(i) out$coefficients[i, c(1, 2, 5)]))
}
extract_cox_results <- function(cg, ff, cov) {
cov$cpg <- as.vector(t(cg))
out <- tryCatch(summary(coxph(ff, data = cov)), error = function(e) return(NA))
if (is.na(out)) return(rep(NA, 4))
c(as.vector(out$conf.int[1, c(1, 3, 4)]), out$coefficients[1, 5])
}
ewasfun <- switch(model,
"lm"   = function(cg, ff, cov) extract_lm_results(cg, ff, cov, facnum),
"lmer" = function(cg, ff, cov) extract_lmer_results(cg, ff, cov, facnum),
"cox"  = extract_cox_results
)
model -> input$model
## set ewas parameter
VarCov <- if (!is.null(cov)) unlist(strsplit(cov, ",")) else character(0)
required_cols <- switch(model,
"lm"   = c(expo, VarCov),
"lmer" = c(expo, VarCov, random),
"cox"  = c(time, status, VarCov)
)
covdata <- input$Data$Expo[, required_cols, drop = FALSE]
if (model == "lmer") {
colnames(covdata)[match(random, colnames(covdata))] <- "random"
input$random <- random
} else if (model == "cox") {
colnames(covdata)[match(time, colnames(covdata))] <- "time"
colnames(covdata)[match(status, colnames(covdata))] <- "status"
input$time <- time
input$status <- status
}
input$covdata <- covdata
formula <- switch (model,
"lm" = as.formula(paste0("cpg ~ ",paste(colnames(covdata), collapse = " + "))),
"lmer" = as.formula(paste0("cpg ~ ",paste(colnames(covdata)[-random_index],
collapse = " + "), " + (1 | random)")),
"cox" = {
if(length(VarCov) > 0){
as.formula(paste0("Surv(time, status) ~ cpg + ", paste(VarCov, collapse = "+")))
}else{
as.formula("Surv(time, status) ~ cpg")
}
}
)
formula -> input$formula
sample_names <- input$Data$Expo[[1]]
df_beta <- input$Data$Methy[, sample_names, drop = FALSE]
rownames(df_beta) <- input$Data$Methy[[1]]
## set parallel parameters----
message("Start the EWAS analysis...")
len = nrow(df_beta)
chunk.size <- ceiling(len/no_cores)
result_cols <- switch(model,
"lm" = 3 * (facnum - 1),
"lmer" = 3 * (facnum - 1),
"cox" = 4
) # identify number of columns that each model returns
cl <- makeCluster(no_cores)
registerDoParallel(cl)
clusterExport(cl, varlist = c("ewasfun", "formula", "covdata", "df_beta", "facnum"), envir = environment())
if (model == "lmer") clusterEvalQ(cl, library(lmerTest))
if (model == "cox") clusterEvalQ(cl, library(survival))
## parallel computing-------
if(model %in% c("lm","lmer")){
system.time(
modelres <- foreach(i=1:no_cores, .combine='rbind') %dopar%
{  # local data for results
restemp <- matrix(0, nrow=min(chunk.size, len-(i-1)*chunk.size), ncol=3*(facnum-1))
for(x in ((i-1)*chunk.size+1):min(i*chunk.size, len)) {
restemp[x - (i-1)*chunk.size,] <- as.numeric(base::t(ewasfun(df_beta[x,],formula,covdata)))
}
# return local results
restemp
}
)
}else{
system.time(
modelres <- foreach(i=1:no_cores, .combine='rbind') %dopar%
{  # local data for results
restemp <- matrix(0, nrow=min(chunk.size, len-(i-1)*chunk.size), ncol=4)
for(x in ((i-1)*chunk.size+1):min(i*chunk.size, len)) {
restemp[x - (i-1)*chunk.size,] <- as.numeric(base::t(ewasfun(df_beta[x,],formula,covdata)))
}
# return local results
restemp
}
)
}
stopImplicitCluster()
stopCluster(cl)
modelres = modelres[1:len,]
res$Data$Expo
input = res
filename ="default"
model = "lm"
expo = 'age'
cov = "sex,LYMPHPER,BMI"
cov = NULL
random = NULL
time = NULL
status = NULL
adjustP = TRUE
chipType = "EPICV2"
core = 6
res <- startEWAS(res,
filename =filename,
model = model,
expo = expo,
cov = cov,
random = random,
time = time,
status = status,
adjustP = adjustP,
chipType = chipType,
core = core)
stopImplicitCluster()
stopCluster(cl)
modelres = modelres[1:len,]
cl <- makeCluster(no_cores)
registerDoParallel(cl)
clusterExport(cl, varlist = c("ewasfun", "formula", "covdata", "df_beta", "facnum"), envir = environment())
if (model == "lmer") clusterEvalQ(cl, library(lmerTest))
if (model == "cox") clusterEvalQ(cl, library(survival))
## parallel computing-------
if(model %in% c("lm","lmer")){
system.time(
modelres <- foreach(i=1:no_cores, .combine='rbind') %dopar%
{  # local data for results
restemp <- matrix(0, nrow=min(chunk.size, len-(i-1)*chunk.size), ncol=3*(facnum-1))
for(x in ((i-1)*chunk.size+1):min(i*chunk.size, len)) {
restemp[x - (i-1)*chunk.size,] <- as.numeric(base::t(ewasfun(df_beta[x,],formula,covdata)))
}
# return local results
restemp
}
)
}else{
system.time(
modelres <- foreach(i=1:no_cores, .combine='rbind') %dopar%
{  # local data for results
restemp <- matrix(0, nrow=min(chunk.size, len-(i-1)*chunk.size), ncol=4)
for(x in ((i-1)*chunk.size+1):min(i*chunk.size, len)) {
restemp[x - (i-1)*chunk.size,] <- as.numeric(base::t(ewasfun(df_beta[x,],formula,covdata)))
}
# return local results
restemp
}
)
}
chunk.size
len
no_cores
cl <- makeCluster(no_cores)
registerDoParallel(cl)
clusterExport(cl, varlist = c("ewasfun", "formula", "covdata", "df_beta", "facnum", "result_cols"), envir = environment())
if (model == "lmer") clusterEvalQ(cl, library(lmerTest))
if (model == "cox")  clusterEvalQ(cl, library(survival))
## parallel computing ----
system.time({
modelres <- foreach(i = 1:no_cores, .combine = 'rbind') %dopar% {
start <- (i - 1) * chunk.size + 1
end <- min(i * chunk.size, len)
# 如果当前 core 没有任务则跳过
if (start > end) return(NULL)
n_rows <- end - start + 1
restemp <- matrix(NA_real_, nrow = n_rows, ncol = result_cols)
for (j in seq_len(n_rows)) {
idx <- start + j - 1
restemp[j, ] <- tryCatch(
as.numeric(base::t(ewasfun(df_beta[idx, , drop = FALSE], formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
}
restemp
}
})
stopImplicitCluster()
stopCluster(cl)
modelres = modelres[1:len,]
modelres
cl <- makeCluster(no_cores)
registerDoParallel(cl)
clusterExport(cl, varlist = c("ewasfun", "formula", "covdata", "df_beta", "facnum"), envir = environment())
if (model == "lmer") clusterEvalQ(cl, library(lmerTest))
if (model == "cox") clusterEvalQ(cl, library(survival))
## parallel computing-------
if(model %in% c("lm","lmer")){
system.time(
modelres <- foreach(i=1:no_cores, .combine='rbind') %dopar%
{  # local data for results
restemp <- matrix(0, nrow=min(chunk.size, len-(i-1)*chunk.size), ncol=3*(facnum-1))
for(x in ((i-1)*chunk.size+1):min(i*chunk.size, len)) {
restemp[x - (i-1)*chunk.size,] <- as.numeric(base::t(ewasfun(df_beta[x,],formula,covdata)))
}
# return local results
restemp
}
)
}else{
system.time(
modelres <- foreach(i=1:no_cores, .combine='rbind') %dopar%
{  # local data for results
restemp <- matrix(0, nrow=min(chunk.size, len-(i-1)*chunk.size), ncol=4)
for(x in ((i-1)*chunk.size+1):min(i*chunk.size, len)) {
restemp[x - (i-1)*chunk.size,] <- as.numeric(base::t(ewasfun(df_beta[x,],formula,covdata)))
}
# return local results
restemp
}
)
}
df_beta
## set cores number----
cl <- makeCluster(no_cores)
registerDoParallel(cl, cores=no_cores)
if(model == "lmer"){
clusterEvalQ(cl, library(lmerTest))
}
if(model == "cox"){
clusterEvalQ(cl, library(survival))
}
## parallel computing-------
message("Start the EWAS analysis...")
len = nrow(df_beta)
chunk.size <- ceiling(len/no_cores)
if(model %in% c("lm","lmer")){
system.time(
modelres <- foreach(i=1:no_cores, .combine='rbind') %dopar%
{  # local data for results
restemp <- matrix(0, nrow=min(chunk.size, len-(i-1)*chunk.size), ncol=3*(facnum-1))
for(x in ((i-1)*chunk.size+1):min(i*chunk.size, len)) {
restemp[x - (i-1)*chunk.size,] <- as.numeric(base::t(ewasfun(df_beta[x,],formula,covdata)))
}
# return local results
restemp
}
)
}else{
system.time(
modelres <- foreach(i=1:no_cores, .combine='rbind') %dopar%
{  # local data for results
restemp <- matrix(0, nrow=min(chunk.size, len-(i-1)*chunk.size), ncol=4)
for(x in ((i-1)*chunk.size+1):min(i*chunk.size, len)) {
restemp[x - (i-1)*chunk.size,] <- as.numeric(base::t(ewasfun(df_beta[x,],formula,covdata)))
}
# return local results
restemp
}
)
}
stopImplicitCluster()
stopCluster(cl)
modelres = modelres[1:len,]
