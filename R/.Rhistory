)
covdata <- input$Data$Expo[, required_cols, drop = FALSE]
if (model == "lmer") {
colnames(covdata)[match(random, colnames(covdata))] <- "random"
input$random <- random
} else if (model == "cox") {
colnames(covdata)[match(time, colnames(covdata))] <- "time"
colnames(covdata)[match(status, colnames(covdata))] <- "status"
input$time <- time
input$status <- status
}
input$covdata <- covdata
formula <- switch (model,
"lm" = as.formula(paste0("cpg ~ ",paste(colnames(covdata), collapse = " + "))),
"lmer" = as.formula(paste0("cpg ~ ",paste(colnames(covdata)[-random_index],
collapse = " + "), " + (1 | random)")),
"cox" = {
if(length(VarCov) > 0){
as.formula(paste0("Surv(time, status) ~ cpg + ", paste(VarCov, collapse = "+")))
}else{
as.formula("Surv(time, status) ~ cpg")
}
}
)
formula -> input$formula
sample_names <- input$Data$Expo[[1]]
df_beta <- input$Data$Methy[, sample_names, drop = FALSE]
rownames(df_beta) <- input$Data$Methy[[1]]
## set parallel parameters----
message("Start the EWAS analysis...")
len = nrow(df_beta)
chunk.size <- ceiling(len/no_cores)
result_cols <- switch(model,
"lm" = 3 * (facnum - 1),
"lmer" = 3 * (facnum - 1),
"cox" = 4
) # identify number of columns that each model returns
cl <- makeCluster(no_cores)
registerDoParallel(cl)
clusterExport(cl, varlist = c("ewasfun", "formula", "covdata", "df_beta", "facnum"), envir = environment())
if (model == "lmer") clusterEvalQ(cl, library(lmerTest))
if (model == "cox") clusterEvalQ(cl, library(survival))
## parallel computing-------
if(model %in% c("lm","lmer")){
system.time(
modelres <- foreach(i=1:no_cores, .combine='rbind') %dopar%
{  # local data for results
restemp <- matrix(0, nrow=min(chunk.size, len-(i-1)*chunk.size), ncol=3*(facnum-1))
for(x in ((i-1)*chunk.size+1):min(i*chunk.size, len)) {
restemp[x - (i-1)*chunk.size,] <- as.numeric(base::t(ewasfun(df_beta[x,],formula,covdata)))
}
# return local results
restemp
}
)
}else{
system.time(
modelres <- foreach(i=1:no_cores, .combine='rbind') %dopar%
{  # local data for results
restemp <- matrix(0, nrow=min(chunk.size, len-(i-1)*chunk.size), ncol=4)
for(x in ((i-1)*chunk.size+1):min(i*chunk.size, len)) {
restemp[x - (i-1)*chunk.size,] <- as.numeric(base::t(ewasfun(df_beta[x,],formula,covdata)))
}
# return local results
restemp
}
)
}
source("D:/myweb/easyEWAS/R/startEWAS.R")
res$Data$Expo
input = res
filename ="default"
model = "lm"
expo = 'age'
cov = "sex,LYMPHPER,BMI"
cov = NULL
random = NULL
time = NULL
status = NULL
adjustP = TRUE
chipType = "EPICV2"
core = 6
res <- startEWAS(res,
filename =filename,
model = model,
expo = expo,
cov = cov,
random = random,
time = time,
status = status,
adjustP = adjustP,
chipType = chipType,
core = core)
?lapply
modelres
library(progressr)
cl <- makeCluster(no_cores)
registerDoParallel(cl)
clusterExport(cl, varlist = c("ewasfun", "formula", "covdata", "df_beta", "facnum"), envir = environment())
if (model == "lmer") clusterEvalQ(cl, library(lmerTest))
if (model == "cox") clusterEvalQ(cl, library(survival))
## parallel computing-------
if(model %in% c("lm","lmer")){
system.time(
handlers(global = TRUE)
with_progress({
## parallel computing-------
if(model %in% c("lm","lmer")){
system.time(
handlers(global = TRUE)
with_progress({
system.time(
handlers(global = TRUE)
with_progress({
handlers(global = TRUE)
with_progress({
p <- progressor(steps = len)
modelres <- foreach(i=1:no_cores, .combine='rbind') %dopar%
{  # local data for results
restemp <- matrix(0, nrow=min(chunk.size, len-(i-1)*chunk.size), ncol=3*(facnum-1))
for(x in ((i-1)*chunk.size+1):min(i*chunk.size, len)) {
restemp[x - (i-1)*chunk.size,] <- as.numeric(base::t(ewasfun(df_beta[x,],formula,covdata)))
p()
}
# return local results
restemp
}
})
stopImplicitCluster()
stopCluster(cl)
modelres = modelres[1:len,]
## set parallel parameters----
message("Start the EWAS analysis...")
len = nrow(df_beta)
chunk.size <- ceiling(len/no_cores)
result_cols <- switch(model,
"lm" = 3 * (facnum - 1),
"lmer" = 3 * (facnum - 1),
"cox" = 4
) # identify number of columns that each model returns
cl <- makeCluster(no_cores)
registerDoParallel(cl)
clusterExport(cl, varlist = c("ewasfun", "formula", "covdata", "df_beta", "facnum"), envir = environment())
if (model == "lmer") clusterEvalQ(cl, library(lmerTest))
if (model == "cox") clusterEvalQ(cl, library(survival))
## parallel computing-------
if(model %in% c("lm","lmer")){
system.time(
handlers(global = TRUE)
with_progress({
system.time(
handlers(global = TRUE)
with_progress({
system.time(
handlers(global = TRUE)
with_progress({
with_progress({
p <- progressor(steps = len)
modelres <- foreach(i=1:no_cores, .combine='rbind') %dopar%
{  # local data for results
restemp <- matrix(0, nrow=min(chunk.size, len-(i-1)*chunk.size), ncol=3*(facnum-1))
for(x in ((i-1)*chunk.size+1):min(i*chunk.size, len)) {
restemp[x - (i-1)*chunk.size,] <- as.numeric(base::t(ewasfun(df_beta[x,],formula,covdata)))
p()
}
# return local results
restemp
}
})
len
library(progressr)
handlers(global = TRUE)  # 启用默认进度条处理器
with_progress({
p <- progressor(steps = len)
modelres <- foreach(i = 1:no_cores, .combine = 'rbind') %dopar% {
# 根据模型选择列数
result_cols <- if (model %in% c("lm", "lmer")) 3 * (facnum - 1) else 4
restemp <- matrix(NA_real_, nrow = min(chunk.size, len - (i - 1) * chunk.size), ncol = result_cols)
for (x in ((i - 1) * chunk.size + 1):min(i * chunk.size, len)) {
res <- tryCatch(
as.numeric(base::t(ewasfun(df_beta[x, ], formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
restemp[x - (i - 1) * chunk.size, ] <- res
p()  # 更新进度条
}
restemp
}
})
library(progressr)
handlers(global = TRUE)  # 启用默认进度条处理器
with_progress({
p <- progressor(steps = len)
modelres <- foreach(i = 1:no_cores, .combine = 'rbind') %dopar% {
# 根据模型选择列数
result_cols <- if (model %in% c("lm", "lmer")) 3 * (facnum - 1) else 4
restemp <- matrix(NA_real_, nrow = min(chunk.size, len - (i - 1) * chunk.size), ncol = result_cols)
for (x in ((i - 1) * chunk.size + 1):min(i * chunk.size, len)) {
res <- tryCatch(
as.numeric(base::t(ewasfun(df_beta[x, ], formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
restemp[x - (i - 1) * chunk.size, ] <- res
p()  # 更新进度条
}
restemp
}
})
library(future)
library(furrr)
library(progressr)
install.packages("furrr")
library(future)
library(furrr)
library(progressr)
plan(multisession, workers = no_cores)  # 或 multicore（Linux/macOS）
handlers(global = TRUE)  # 启用进度条
with_progress({
p <- progressor(along = 1:len)
modelres_list <- future_map(1:len, function(i) {
p()  # 更新进度条
tryCatch(
as.numeric(t(ewasfun(df_beta[i, , drop = FALSE], formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
}, .options = furrr_options(seed = TRUE))  # 保证可复现
modelres <- do.call(rbind, modelres_list)
})
with_progress({
p <- progressor(steps = len)  # 明确设置步骤数
modelres_list <- future_map(1:len, function(i) {
on.exit(p(), add = TRUE)  # 每轮都确保调用一次 p()
tryCatch(
as.numeric(t(ewasfun(df_beta[i, , drop = FALSE], formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
}, .options = furrr_options(seed = TRUE))
})
library(progressr)
handlers(global = TRUE)
message("Start the EWAS analysis...")
len <- nrow(df_beta)
chunk.size <- ceiling(len / no_cores)
result_cols <- switch(model,
"lm" = 3 * (facnum - 1),
"lmer" = 3 * (facnum - 1),
"cox" = 4)
# 启动并行集群
cl <- makeCluster(no_cores)
registerDoParallel(cl)
# 向每个 worker 显式传递变量
clusterExport(cl, varlist = c("ewasfun", "formula", "covdata", "df_beta", "facnum", "model", "result_cols"), envir = environment())
# 加载模型相关包
clusterEvalQ(cl, {
if ("lmer" %in% model) library(lmerTest, quietly = TRUE)
if ("cox" %in% model) library(survival, quietly = TRUE)
NULL
})
# 启用进度条跟踪
with_progress({
p <- progressor(steps = len)
modelres <- foreach(i = seq_len(no_cores), .combine = 'rbind') %dopar% {
start_row <- (i - 1) * chunk.size + 1
end_row <- min(i * chunk.size, len)
n_rows <- end_row - start_row + 1
restemp <- matrix(NA_real_, nrow = n_rows, ncol = result_cols)
for (j in seq_len(n_rows)) {
row_idx <- start_row + j - 1
res <- tryCatch(
as.numeric(t(ewasfun(df_beta[row_idx, , drop = FALSE], formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
restemp[j, ] <- res
# 安全触发进度更新：进程间通信安全版本
progressr:::progressor_fun("update", amount = 1)
}
restemp
}
})
library(furrr)
library(progressr)
handlers("txtprogressbar")  # 或 shiny, cli 等
plan(multisession, workers = no_cores)
message("Start the EWAS analysis...")
len <- nrow(df_beta)
result_cols <- switch(model,
"lm" = 3 * (facnum - 1),
"lmer" = 3 * (facnum - 1),
"cox" = 4)
with_progress({
p <- progressor(steps = len)
modelres_list <- future_map(1:len, function(i) {
on.exit(p(), add = TRUE)
tryCatch(
as.numeric(t(ewasfun(df_beta[i, , drop = FALSE], formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
}, .options = furrr_options(seed = TRUE))
})
with_progress({
p <- progressor(steps = len)
modelres_list <- future_map(1:len, function(i) {
on.exit(p(), add = TRUE)  # 保证每个任务无论成功失败都只调用一次 p()
tryCatch(
as.numeric(t(ewasfun(df_beta[i, , drop = FALSE], formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
}, .options = furrr_options(seed = TRUE))
})
progressr::handlers("debug")
plan(multisession, workers = no_cores)
message("Start the EWAS analysis...")
len <- nrow(df_beta)
result_cols <- switch(model,
"lm" = 3 * (facnum - 1),
"lmer" = 3 * (facnum - 1),
"cox" = 4)
with_progress({
p <- progressor(steps = len)
modelres_list <- future_map(1:len, function(i) {
on.exit(p(), add = TRUE)  # 保证每个任务无论成功失败都只调用一次 p()
tryCatch(
as.numeric(t(ewasfun(df_beta[i, , drop = FALSE], formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
}, .options = furrr_options(seed = TRUE))
})
handlers("txtprogressbar")  # 或 shiny, cli 等
plan(multisession, workers = no_cores)
message("Start the EWAS analysis...")
len <- nrow(df_beta)
result_cols <- switch(model,
"lm" = 3 * (facnum - 1),
"lmer" = 3 * (facnum - 1),
"cox" = 4)
with_progress({
p <- progressor(steps = len)
modelres_list <- future_map(1:len, function(i) {
on.exit(p(), add = TRUE)  # 保证每个任务无论成功失败都只调用一次 p()
tryCatch(
as.numeric(t(ewasfun(df_beta[i, , drop = FALSE], formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
}, .options = furrr_options(seed = TRUE))
})
modelres <- do.call(rbind, modelres_list)
handlers("cli")  # 或 shiny, cli 等
plan(multisession, workers = no_cores)
message("Start the EWAS analysis...")
len <- nrow(df_beta)
result_cols <- switch(model,
"lm" = 3 * (facnum - 1),
"lmer" = 3 * (facnum - 1),
"cox" = 4)
with_progress({
p <- progressor(steps = len)
modelres_list <- future_map(1:len, function(i) {
on.exit(p(), add = TRUE)  # 保证每个任务无论成功失败都只调用一次 p()
tryCatch(
as.numeric(t(ewasfun(df_beta[i, , drop = FALSE], formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
}, .options = furrr_options(seed = TRUE))
})
handlers("shiny")  # 或 shiny, cli 等
plan(multisession, workers = no_cores)
message("Start the EWAS analysis...")
len <- nrow(df_beta)
result_cols <- switch(model,
"lm" = 3 * (facnum - 1),
"lmer" = 3 * (facnum - 1),
"cox" = 4)
with_progress({
p <- progressor(steps = len)
modelres_list <- future_map(1:len, function(i) {
on.exit(p(), add = TRUE)  # 保证每个任务无论成功失败都只调用一次 p()
tryCatch(
as.numeric(t(ewasfun(df_beta[i, , drop = FALSE], formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
}, .options = furrr_options(seed = TRUE))
})
with_progress({
p <- progressor(steps = len)
modelres_list <- future_map(1:len, function(i) {
on.exit(p(), add = TRUE)  # 保证每个任务无论成功失败都只调用一次 p()
tryCatch(
as.numeric(t(ewasfun(df_beta[i, , drop = FALSE], formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
}, .options = furrr_options(seed = TRUE))
})
handlers("txtprogressbar")  # 或 shiny, cli 等
plan(multisession, workers = no_cores)
message("Start the EWAS analysis...")
len <- nrow(df_beta)
result_cols <- switch(model,
"lm" = 3 * (facnum - 1),
"lmer" = 3 * (facnum - 1),
"cox" = 4)
with_progress({
p <- progressor(steps = len)
modelres_list <- future_map(1:len, function(i) {
on.exit(p(), add = TRUE)  # 保证每个任务无论成功失败都只调用一次 p()
tryCatch(
as.numeric(t(ewasfun(df_beta[i, , drop = FALSE], formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
}, .options = furrr_options(seed = TRUE))
})
with_progress({
p <- progressor(steps = len)
modelres_list <- future_map(1:len, function(i) {
on.exit(p(), add = TRUE)  # 保证每个任务无论成功失败都只调用一次 p()
tryCatch(
as.numeric(t(ewasfun(df_beta[i, , drop = FALSE], formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
}, .options = furrr_options(seed = TRUE))
})
library(furrr)
library(progressr)
handlers("txtprogressbar")  # 或 shiny, cli 等
plan(multisession, workers = no_cores)
message("Start the EWAS analysis...")
len <- nrow(df_beta)
result_cols <- switch(model,
"lm" = 3 * (facnum - 1),
"lmer" = 3 * (facnum - 1),
"cox" = 4)
with_progress({
p <- progressor(steps = len)
modelres_list <- future_map(1:len, function(i) {
on.exit(p(), add = TRUE)
tryCatch(
as.numeric(t(ewasfun(df_beta[i, , drop = FALSE], formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
}, .options = furrr_options(seed = TRUE))
})
modelres <- do.call(rbind, modelres_list)
with_progress({
p <- progressor(steps = len)
modelres_list <- future_map(1:len, function(i) {
on.exit(p(), add = TRUE)
tryCatch(
as.numeric(t(ewasfun(df_beta[i, , drop = FALSE], formula, covdata))),
error = function(e) rep(NA_real_, result_cols)
)
}, .options = furrr_options(seed = TRUE))
})
modelres <- do.call(rbind, modelres_list)
detach("package:easyEWAS", unload = TRUE, character.only = TRUE)
remove.packages("easyEWAS")
remotes::install_github("ytwangZero/easyEWAS")
library(easyEWAS)
library(tidyverse)
library(parallel)
library(foreach)
library(doParallel)
library(progressr)
res <- initEWAS(outpath = outpath)
res <- loadEWAS(input = res, ExpoPath =  ExpoPath, MethyPath = MethyPath)
res$Data$Expo
Vars = "sex,batch"
res <- transEWAS(res, Vars = Vars, TypeTo = "factor")
adjustVar = "sex,age"
batch = "batch"
plot = TRUE
par.prior = TRUE
mean.only = FALSE
ref.batch = NULL
parallel = FALSE
core = NULL
colnames(res$Data$Expo)
res <- batchEWAS(input = res, adjustVar = adjustVar,
batch = "batch", parallel = F, core = 1)
res$Data$Expo
input = res
filename ="default"
model = "lm"
expo = 'age'
cov = "sex,LYMPHPER,BMI"
cov = NULL
random = NULL
time = NULL
status = NULL
adjustP = TRUE
chipType = "EPICV2"
core = 6
res <- startEWAS(res,
filename =filename,
model = model,
expo = expo,
cov = cov,
random = random,
time = time,
status = status,
adjustP = adjustP,
chipType = chipType,
core = core)
res <- easyEWAS::startEWAS(res,
filename =filename,
model = model,
expo = expo,
cov = cov,
random = random,
time = time,
status = status,
adjustP = adjustP,
chipType = chipType,
core = core)
